1.키워드란 무엇인가?
 - static, void, main 등등을 일컫는다. 

2.2의 보수법이란?
 - 양의 정수 표현법을 기반으로 음의 정수를 표현한다면 두 개의 합이 0이 저장되어야 하지만 오류가 발생됨.
   오류를 방지하기 위해 2의 보수법을 이용하여 음의 정수를 표현

3.컴퓨터에서 음의 정수 표현방법에 대하여 설명하시오.
 - 양의 정수 이진수에 1의 보수를 취한 후, 그 값에 1을 더하여 음의 정수를 표현.

4.-5가 컴퓨터에서의 2진수 값을 나타내시오.
 - 11111011

5.실수에서 오차가 생기는 원인은 무엇인가?
 - 유한한 공간을 지닌 메모리에 비해 실수는 범위가 아무리 작더라도 존재하는 실수가 무한대이므로 
   한정된 메모리에 실수를 저장하기 위해 범위를 정하고 범위 내에 숫자를 지정하게 되는데, 
   이 때 지목 된 값을 정해진 숫자의 근사값으로 결정하게 되므로 오차가 발생하게 된다.
   (범위가 클수록 오차↑, 작을수록 오차↓)

6.실수의 표현법은(고정소수법, 부동소수법)을 설명하시오.
 - 고정소수법이란? 0.1234, 1.234, 12.34 등과 같이 사용자가 소수점을 고정해서 사용하는 방법.
 - 부동소수법이란? 0.1234x10, 0.1234x10의2승, 0.1234x10의3승 등과 같이 숫자를 고정시켜 사용하는 방법.

7.정밀도란 무엇인가요?
 - 정밀도란? 소수점이 고정되는 자리
 - float 타입은 소수점 이하 6자리 (6자리의 정밀도), double 타입은  소수점 이하 15자리 (15자리의 정밀도)

8.상수란 무엇이며 변수와의 차이는?
 - 상수란? 단 한 번만 값을 할당할 수 있으며 변경이 불가능하다.
 - 변수와의 차이점? 상수는 값이 변하지 않지만 변수는 입력될 때마다 값이 변하며, 
   상수 입력 시 변수와는 다르게 final + 타입 + 변수명(대문자)로 표기해야 함.  
   ex) final int MAX_SIZE = 100;

9.초기화란 무엇인가?
 - 해당 변수에 처음으로 값을 넣는 행위.
  ex) 1. final double PI = 3.14;
      2. final double PI
         PI = 3.1415;

10.리터럴이란 무엇인가요?
 - 자료형을 기반으로 표현되는 상수를 의미하며, 정수형 리터럴은 int형으로 실수형 리터럴은 double형으로 인식 
 - long형 리터럴 표현방법: 정수 + L 혹은 l 
 - double형 리터럴 표현방법: 실수 + D 혹은 d
 - float형 리터럴 표현방법: 실수 + F 혹은 f

11.아래의 내용이 에러가 나는 이유와 수정방법은? System.out.println(3147483647 + 3147483648);
 - 리터럴이 int가 지닐 수 있는 크기를 넘은 long의 값을 지니므로 오류가 발생하며, 
   System.out.println(3147483647L + 3147483648L); 이처럼 숫자 뒤에 L을 붙여줘야 long 타입으로 인식.

12.자동 형변환과 명시적 형변환에 대하여 설명하시오.
 - 자동 형변환이란? 
   두 개의 다른 자료형을 연산하게 되는 경우 자동으로 한 개의 타입을 다른 타입과 동일하게 변환하여 컴파일.
   (자동 형변환이 일어나는 이유? 연산은 반드시 데이터 타입이 같아야 하기 때문)
 - 명시적 형변환이란? 
   강제적 형변환이라고도 하며, 원칙상으로는 성립되지 않지만 필요한 경우 자료형을 강제적으로 변환시키는 것.

13.아래의 에러가 나는 이유를 설명하고 수정하시오.
    	int a = 3;
    	int b = 4;
    	
    	double result = a / b;
    	
    	System.out.println(result);

 - 오류가 나는 이유? a와 b는 int 타입으로 선언되었으므로 double 타입이 아닌 int 타입인 0이 저장됨. 
   (값을 생각하기 이전에 a와 b가 어떤 자료형인지 먼저 생각해 볼 것!)
   * a 혹은 b를 double로 명시적 형 변환:  double result = (double)a / b;  double result = a / (double)b;  
   * int를 double a = 3; 혹은 double b = 4; 로 수정

14.이스퀘이프 시퀀스의 종류를 나열하고 기능을 설명하시오.
 - '＼b' 백스페이스: 뒤에 있는 문자를 뒤에 붙여주는 기능
 - '＼t' tab: 문자와 문자 사이를 tab 만큼 띄어주는 기능
 - '＼＼ ' 백슬래시
 - '＼'' 작은 따옴표: 전산상에서 충돌 방지를 위해 따옴표를 구별해주는 기능
 - '＼"' 큰 따옴표: 전산상에서 충돌 방지를 위해 따옴표를 구별해주는 기능
 - '＼n' 개 행 문자: 그 다음 줄로 열어서 컴파일하는 기능
 - '＼r' 캐리지 리턴: 뒤에 문자를 앞으로 리턴시키고  앞에 문자는 다음 줄로 열어서 컴파일하는 기능

15.아래의 출력결과를 확인하고, 130이 나오는 이유를 설명하시오.
 System.out.println('A' + 'A');
 - 문자 A는 아스키 코드표 10진수에서 65를 뜻하므로 65 + 65 = 130을 저장하게 됨.
